/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/polyfill/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/polyfill/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(/*! core-js/es6 */ "./node_modules/core-js/es6/index.js");

__webpack_require__(/*! core-js/fn/array/includes */ "./node_modules/core-js/fn/array/includes.js");

__webpack_require__(/*! core-js/fn/string/pad-start */ "./node_modules/core-js/fn/string/pad-start.js");

__webpack_require__(/*! core-js/fn/string/pad-end */ "./node_modules/core-js/fn/string/pad-end.js");

__webpack_require__(/*! core-js/fn/symbol/async-iterator */ "./node_modules/core-js/fn/symbol/async-iterator.js");

__webpack_require__(/*! core-js/fn/object/get-own-property-descriptors */ "./node_modules/core-js/fn/object/get-own-property-descriptors.js");

__webpack_require__(/*! core-js/fn/object/values */ "./node_modules/core-js/fn/object/values.js");

__webpack_require__(/*! core-js/fn/object/entries */ "./node_modules/core-js/fn/object/entries.js");

__webpack_require__(/*! core-js/fn/promise/finally */ "./node_modules/core-js/fn/promise/finally.js");

__webpack_require__(/*! core-js/web */ "./node_modules/core-js/web/index.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

if (global._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

global._babelPolyfill = true;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/es6/index.js":
/*!*******************************************!*\
  !*** ./node_modules/core-js/es6/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ../modules/es6.object.create */ "./node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ../modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ../modules/es6.object.define-properties */ "./node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ../modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ../modules/es6.object.get-prototype-of */ "./node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ../modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ../modules/es6.object.get-own-property-names */ "./node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ../modules/es6.object.freeze */ "./node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ../modules/es6.object.seal */ "./node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ../modules/es6.object.prevent-extensions */ "./node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ../modules/es6.object.is-frozen */ "./node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ../modules/es6.object.is-sealed */ "./node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ../modules/es6.object.is-extensible */ "./node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ../modules/es6.object.assign */ "./node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ../modules/es6.object.is */ "./node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ../modules/es6.object.set-prototype-of */ "./node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ../modules/es6.function.bind */ "./node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ../modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ../modules/es6.function.has-instance */ "./node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ../modules/es6.parse-int */ "./node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ../modules/es6.parse-float */ "./node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ../modules/es6.number.constructor */ "./node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ../modules/es6.number.to-fixed */ "./node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ../modules/es6.number.to-precision */ "./node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ../modules/es6.number.epsilon */ "./node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ../modules/es6.number.is-finite */ "./node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ../modules/es6.number.is-integer */ "./node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ../modules/es6.number.is-nan */ "./node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ../modules/es6.number.is-safe-integer */ "./node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.max-safe-integer */ "./node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.min-safe-integer */ "./node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.parse-float */ "./node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ../modules/es6.number.parse-int */ "./node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ../modules/es6.math.acosh */ "./node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ../modules/es6.math.asinh */ "./node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ../modules/es6.math.atanh */ "./node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ../modules/es6.math.cbrt */ "./node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ../modules/es6.math.clz32 */ "./node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ../modules/es6.math.cosh */ "./node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ../modules/es6.math.expm1 */ "./node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ../modules/es6.math.fround */ "./node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ../modules/es6.math.hypot */ "./node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ../modules/es6.math.imul */ "./node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ../modules/es6.math.log10 */ "./node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ../modules/es6.math.log1p */ "./node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ../modules/es6.math.log2 */ "./node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ../modules/es6.math.sign */ "./node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ../modules/es6.math.sinh */ "./node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ../modules/es6.math.tanh */ "./node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ../modules/es6.math.trunc */ "./node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ../modules/es6.string.from-code-point */ "./node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ../modules/es6.string.raw */ "./node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ../modules/es6.string.trim */ "./node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ../modules/es6.string.code-point-at */ "./node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ../modules/es6.string.ends-with */ "./node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ../modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ../modules/es6.string.repeat */ "./node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ../modules/es6.string.starts-with */ "./node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ../modules/es6.string.anchor */ "./node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ../modules/es6.string.big */ "./node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ../modules/es6.string.blink */ "./node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ../modules/es6.string.bold */ "./node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ../modules/es6.string.fixed */ "./node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ../modules/es6.string.fontcolor */ "./node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ../modules/es6.string.fontsize */ "./node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ../modules/es6.string.italics */ "./node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ../modules/es6.string.link */ "./node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ../modules/es6.string.small */ "./node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ../modules/es6.string.strike */ "./node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ../modules/es6.string.sub */ "./node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ../modules/es6.string.sup */ "./node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ../modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ../modules/es6.date.to-json */ "./node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ../modules/es6.date.to-iso-string */ "./node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ../modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ../modules/es6.date.to-primitive */ "./node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ../modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ../modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ../modules/es6.array.of */ "./node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ../modules/es6.array.join */ "./node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ../modules/es6.array.slice */ "./node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ../modules/es6.array.sort */ "./node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ../modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ../modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ../modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ../modules/es6.array.some */ "./node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ../modules/es6.array.every */ "./node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ../modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ../modules/es6.array.reduce-right */ "./node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ../modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ../modules/es6.array.last-index-of */ "./node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ../modules/es6.array.copy-within */ "./node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ../modules/es6.array.fill */ "./node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ../modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ../modules/es6.array.find-index */ "./node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ../modules/es6.array.species */ "./node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ../modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ../modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ../modules/es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ../modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ../modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ../modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ../modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ../modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ../modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ../modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ../modules/es6.map */ "./node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ../modules/es6.set */ "./node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ../modules/es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ../modules/es6.weak-set */ "./node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ../modules/es6.typed.array-buffer */ "./node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ../modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ../modules/es6.typed.int8-array */ "./node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint8-clamped-array */ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ../modules/es6.typed.int16-array */ "./node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ../modules/es6.typed.int32-array */ "./node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ../modules/es6.typed.float32-array */ "./node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ../modules/es6.typed.float64-array */ "./node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ../modules/es6.reflect.apply */ "./node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ../modules/es6.reflect.construct */ "./node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ../modules/es6.reflect.define-property */ "./node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ../modules/es6.reflect.delete-property */ "./node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ../modules/es6.reflect.enumerate */ "./node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ../modules/es6.reflect.get */ "./node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ../modules/es6.reflect.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ../modules/es6.reflect.get-prototype-of */ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ../modules/es6.reflect.has */ "./node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ../modules/es6.reflect.is-extensible */ "./node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ../modules/es6.reflect.own-keys */ "./node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ../modules/es6.reflect.prevent-extensions */ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ../modules/es6.reflect.set */ "./node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ../modules/es6.reflect.set-prototype-of */ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/core-js/fn/array/includes.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/array/includes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Array.includes;

/***/ }),

/***/ "./node_modules/core-js/fn/object/entries.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/object/entries.js ***!
  \***************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);


__webpack_require__(/*! ../../modules/es7.object.entries */ "./node_modules/core-js/modules/es7.object.entries.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Object.entries;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/fn/object/get-own-property-descriptors.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/fn/object/get-own-property-descriptors.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Object.getOwnPropertyDescriptors;

/***/ }),

/***/ "./node_modules/core-js/fn/object/values.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/fn/object/values.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);


__webpack_require__(/*! ../../modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Object.values;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/fn/promise/finally.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/fn/promise/finally.js ***!
  \****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es7_promise_finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.promise.finally */ "./node_modules/core-js/modules/es7.promise.finally.js");
/* harmony import */ var core_js_modules_es7_promise_finally__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_promise_finally__WEBPACK_IMPORTED_MODULE_0__);




__webpack_require__(/*! ../../modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ../../modules/es7.promise.finally */ "./node_modules/core-js/modules/es7.promise.finally.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Promise['finally'];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/fn/string/pad-end.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/fn/string/pad-end.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.pad-end */ "./node_modules/core-js/modules/es7.string.pad-end.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").String.padEnd;

/***/ }),

/***/ "./node_modules/core-js/fn/string/pad-start.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/fn/string/pad-start.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.pad-start */ "./node_modules/core-js/modules/es7.string.pad-start.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").String.padStart;

/***/ }),

/***/ "./node_modules/core-js/fn/symbol/async-iterator.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/fn/symbol/async-iterator.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");

module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js").f('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_a-number-value.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_a-number-value.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);

      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }

  return memo;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_bind.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function bound()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-strong.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-strong.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function get() {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) entry = entry.p; // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-weak.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-weak.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_collection.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);




var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.5'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-iso-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-iso-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-primitive.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-primitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_2__);






__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_function-to-string.js ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

module.exports = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");


// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);




var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-expm1.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-expm1.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-fround.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_math-fround.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-log1p.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-log1p.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-sign.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-sign.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function notify() {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function notify() {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-assign.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-assign.js ***!
  \********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");
 // 19.1.2.1 Object.assign(target, source, ...)





var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  }

  return T;
} : $assign;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function Empty() {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) delete _createDict[PROTOTYPE][enumBugKeys[i]];

  return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) dP.f(O, P = keys[i++], Properties[P]);

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");


// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);


// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-to-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    }

    return result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-float.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-float.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-int.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-int.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "./node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__);




var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__);





var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-html.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-html.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__);



var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-pad.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-repeat.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;

  return res;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-trim.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-trim.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__);



var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_string-ws.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-ws.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run() {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");


// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__);





if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function validate(it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function addGetter(it, key, internal) {
    dP(it, key, {
      get: function get() {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) result[index] = arguments[index++];

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function isTAIndex(target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function constructor() {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function get() {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function getter(that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function setter(that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function addElement(that, index) {
      dP(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function get() {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function get() {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "./node_modules/core-js/modules/_validate-collection.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_validate-collection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.copy-within.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.copy-within.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.every.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.every.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.fill.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.fill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find-index.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find-index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);




var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.join.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.join.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.last-index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;

    return -1;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.of.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.of.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) createProperty(result, index, arguments[index++]);

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce-right.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.slice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.slice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];

    return cloned;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.some.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.some.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.sort.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.sort.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function now() {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-json.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function toISOString() {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.bind.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.has-instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.has-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function value(O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

    return false;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");


var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.map.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.acosh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.acosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.asinh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.asinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.atanh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.atanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cbrt.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cbrt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.clz32.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.clz32.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cosh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cosh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.expm1.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.expm1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.fround.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.fround.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.hypot.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.hypot.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.imul.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.imul.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log10.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log10.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log1p.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log1p.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log2.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log2.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sign.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sinh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sinh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.tanh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.tanh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.trunc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.trunc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.constructor.js ***!
  \****************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");




var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.epsilon.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.epsilon.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-integer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-float.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-float.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-int.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-int.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-fixed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function divide(n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function numToString() {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function log(x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-precision.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-precision.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.assign.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.create.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.create.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-properties.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.freeze.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.freeze.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-extensible.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-frozen.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-sealed.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.seal.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.seal.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-float.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-float.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-int.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-int.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function empty() {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.apply.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.apply.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.construct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.construct.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.define-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) keys.push(key);
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.has.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.has.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function proxy(key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function get() {
        return Base[key];
      },
      set: function set(it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_flags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");


// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__);




var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_0__);




var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__);





var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_flags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");






__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.set.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.set.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.anchor.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.anchor.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.big.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.big.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.blink.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.blink.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.bold.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.bold.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.code-point-at.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.ends-with.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.ends-with.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fixed.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fixed.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontcolor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontsize.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontsize.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.from-code-point.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.italics.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.italics.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.link.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.link.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.raw.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.raw.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.repeat.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.repeat.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.small.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.small.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.starts-with.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.starts-with.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.strike.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.strike.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sub.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sub.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sup.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.trim.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.trim.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
 // ECMAScript 6 symbols shim



var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) $defineProperty(it, key = keys[i++], P[key]);

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) args.push(arguments[i++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float32-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float64-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int16-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int32-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int8-array.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-set.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-set.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.entries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.values.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.finally.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.finally.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function wrap(set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "./node_modules/core-js/web/index.js":
/*!*******************************************!*\
  !*** ./node_modules/core-js/web/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_regexp_match__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");
/* harmony import */ var core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_constructor__WEBPACK_IMPORTED_MODULE_6__);
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.11';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=typeof exports=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){}// No operation performed.
/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});return result;}if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
var sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){}// No operation performed.
/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(typeof define=='function'&&typeof __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")=='object'&&__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
define(function(){return _;});}// Check for `exports` after `define` in case a build optimizer adds it.
else if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else{// Export to the global object.
root._=_;}}).call(undefined);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");
/* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");




/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this || typeof self === "object" && self;
}() || Function("return this")());
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (originalModule) {
  if (!originalModule.webpackPolyfill) {
    var module = Object.create(originalModule); // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    Object.defineProperty(module, "exports", {
      enumerable: true
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./print */ "./src/print.js");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style.scss */ "./src/style.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_scss__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.css */ "./src/style.css");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_3__);





function component() {
  let element = document.createElement('div');
  let btn = document.createElement("button");
  element.innerHTML = lodash__WEBPACK_IMPORTED_MODULE_0__["default"].join(['Hello', 'webpack'], ' ');
  btn.innerHTML = "Click me and check the console!";
  btn.onclick = _print__WEBPACK_IMPORTED_MODULE_1__["default"];
  element.appendChild(btn);
  return element;
}

document.body.appendChild(component());

/***/ }),

/***/ "./src/print.js":
/*!**********************!*\
  !*** ./src/print.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return printMe; });
function printMe() {
  console.log('I get called from print.js!');
}

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/*!*******************************************!*\
  !*** multi @babel/polyfill ./src/main.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! @babel/polyfill */"./node_modules/@babel/polyfill/lib/index.js");
module.exports = __webpack_require__(/*! C:\Users\Bonggt\Documents\webpack-demo\src\main.js */"./src/main.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXM2L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL2FycmF5L2luY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC9lbnRyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcHJvbWlzZS9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL3N0cmluZy9wYWQtZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL3N0cmluZy9wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vc3ltYm9sL2FzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Z1bmN0aW9uLXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191c2VyLWFnZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy93ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByaW50LmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlLnNjc3MiXSwibmFtZXMiOlsicmVxdWlyZSIsImdsb2JhbCIsIl9iYWJlbFBvbHlmaWxsIiwiY29uc29sZSIsIndhcm4iLCJtb2R1bGUiLCJleHBvcnRzIiwiQXJyYXkiLCJpbmNsdWRlcyIsIk9iamVjdCIsImVudHJpZXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwidmFsdWVzIiwiUHJvbWlzZSIsIlN0cmluZyIsInBhZEVuZCIsInBhZFN0YXJ0IiwiZiIsIml0IiwiVHlwZUVycm9yIiwiY29mIiwibXNnIiwiVU5TQ09QQUJMRVMiLCJBcnJheVByb3RvIiwicHJvdG90eXBlIiwidW5kZWZpbmVkIiwia2V5IiwiYXQiLCJTIiwiaW5kZXgiLCJ1bmljb2RlIiwibGVuZ3RoIiwiQ29uc3RydWN0b3IiLCJuYW1lIiwiZm9yYmlkZGVuRmllbGQiLCJpc09iamVjdCIsInRvT2JqZWN0IiwidG9BYnNvbHV0ZUluZGV4IiwidG9MZW5ndGgiLCJjb3B5V2l0aGluIiwidGFyZ2V0Iiwic3RhcnQiLCJPIiwibGVuIiwidG8iLCJmcm9tIiwiZW5kIiwiYXJndW1lbnRzIiwiY291bnQiLCJNYXRoIiwibWluIiwiaW5jIiwiZmlsbCIsInZhbHVlIiwiYUxlbiIsImVuZFBvcyIsInRvSU9iamVjdCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsImN0eCIsIklPYmplY3QiLCJhc2MiLCJUWVBFIiwiJGNyZWF0ZSIsIklTX01BUCIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJOT19IT0xFUyIsImNyZWF0ZSIsImNhbGxiYWNrZm4iLCJ0aGF0Iiwic2VsZiIsInJlc3VsdCIsInZhbCIsInJlcyIsInB1c2giLCJhRnVuY3Rpb24iLCJtZW1vIiwiaXNSaWdodCIsImkiLCJpc0FycmF5IiwiU1BFQ0lFUyIsIm9yaWdpbmFsIiwiQyIsImNvbnN0cnVjdG9yIiwic3BlY2llc0NvbnN0cnVjdG9yIiwiaW52b2tlIiwiYXJyYXlTbGljZSIsInNsaWNlIiwiZmFjdG9yaWVzIiwiY29uc3RydWN0IiwiRiIsImFyZ3MiLCJuIiwiRnVuY3Rpb24iLCJqb2luIiwiYmluZCIsImZuIiwicGFydEFyZ3MiLCJjYWxsIiwiYm91bmQiLCJjb25jYXQiLCJUQUciLCJBUkciLCJ0cnlHZXQiLCJlIiwiVCIsIkIiLCJjYWxsZWUiLCJ0b1N0cmluZyIsImRQIiwicmVkZWZpbmVBbGwiLCJhbkluc3RhbmNlIiwiZm9yT2YiLCIkaXRlckRlZmluZSIsInN0ZXAiLCJzZXRTcGVjaWVzIiwiREVTQ1JJUFRPUlMiLCJmYXN0S2V5IiwidmFsaWRhdGUiLCJTSVpFIiwiZ2V0RW50cnkiLCJlbnRyeSIsIl9pIiwiX2YiLCJrIiwiZ2V0Q29uc3RydWN0b3IiLCJ3cmFwcGVyIiwiTkFNRSIsIkFEREVSIiwiaXRlcmFibGUiLCJfdCIsIl9sIiwiY2xlYXIiLCJkYXRhIiwiciIsInAiLCJuZXh0IiwicHJldiIsImZvckVhY2giLCJ2IiwiaGFzIiwiZ2V0IiwiZGVmIiwic2V0U3Ryb25nIiwiaXRlcmF0ZWQiLCJraW5kIiwiX2siLCJnZXRXZWFrIiwiYW5PYmplY3QiLCJjcmVhdGVBcnJheU1ldGhvZCIsIiRoYXMiLCJhcnJheUZpbmQiLCJhcnJheUZpbmRJbmRleCIsImlkIiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJhIiwiZmluZFVuY2F1Z2h0RnJvemVuIiwic3RvcmUiLCJzZXQiLCJzcGxpY2UiLCJ1ZnN0b3JlIiwiJGV4cG9ydCIsInJlZGVmaW5lIiwibWV0YSIsImZhaWxzIiwiJGl0ZXJEZXRlY3QiLCJzZXRUb1N0cmluZ1RhZyIsImluaGVyaXRJZlJlcXVpcmVkIiwibWV0aG9kcyIsImNvbW1vbiIsIklTX1dFQUsiLCJCYXNlIiwicHJvdG8iLCJmaXhNZXRob2QiLCJLRVkiLCJhZGQiLCJiIiwiTkVFRCIsImluc3RhbmNlIiwiSEFTTlRfQ0hBSU5JTkciLCJUSFJPV1NfT05fUFJJTUlUSVZFUyIsIkFDQ0VQVF9JVEVSQUJMRVMiLCJpdGVyIiwiQlVHR1lfWkVSTyIsIiRpbnN0YW5jZSIsIkciLCJXIiwiY29yZSIsInZlcnNpb24iLCJfX2UiLCIkZGVmaW5lUHJvcGVydHkiLCJjcmVhdGVEZXNjIiwib2JqZWN0IiwiYyIsImFwcGx5IiwiZ2V0VGltZSIsIkRhdGUiLCIkdG9JU09TdHJpbmciLCJ0b0lTT1N0cmluZyIsImx6IiwibnVtIiwiTmFOIiwiaXNGaW5pdGUiLCJSYW5nZUVycm9yIiwiZCIsInkiLCJnZXRVVENGdWxsWWVhciIsIm0iLCJnZXRVVENNaWxsaXNlY29uZHMiLCJzIiwiYWJzIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInRvUHJpbWl0aXZlIiwiTlVNQkVSIiwiaGludCIsImRlZmluZVByb3BlcnR5IiwiZG9jdW1lbnQiLCJpcyIsImNyZWF0ZUVsZW1lbnQiLCJzcGxpdCIsImdldEtleXMiLCJnT1BTIiwicElFIiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJpc0VudW0iLCJoaWRlIiwiUFJPVE9UWVBFIiwidHlwZSIsInNvdXJjZSIsIklTX0ZPUkNFRCIsIklTX0dMT0JBTCIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiUCIsIklTX0JJTkQiLCJleHBQcm90byIsIm93biIsIm91dCIsImV4cCIsIlUiLCJSIiwiTUFUQ0giLCJyZSIsImV4ZWMiLCJkZWZpbmVkIiwid2tzIiwicmVnZXhwRXhlYyIsIlJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTIiwiZ3JvdXBzIiwicmVwbGFjZSIsIlNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyIsIm9yaWdpbmFsRXhlYyIsIlNZTUJPTCIsIkRFTEVHQVRFU19UT19TWU1CT0wiLCJERUxFR0FURVNfVE9fRVhFQyIsImV4ZWNDYWxsZWQiLCJuYXRpdmVSZWdFeHBNZXRob2QiLCJmbnMiLCJtYXliZUNhbGxOYXRpdmUiLCJuYXRpdmVNZXRob2QiLCJyZWdleHAiLCJzdHIiLCJhcmcyIiwiZm9yY2VTdHJpbmdNZXRob2QiLCJkb25lIiwic3RyZm4iLCJyeGZuIiwiUmVnRXhwIiwic3RyaW5nIiwiYXJnIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsInN0aWNreSIsImlzQXJyYXlJdGVyIiwiZ2V0SXRlckZuIiwiQlJFQUsiLCJSRVRVUk4iLCJJVEVSQVRPUiIsIml0ZXJGbiIsIml0ZXJhdG9yIiwid2luZG93IiwiX19nIiwiaGFzT3duUHJvcGVydHkiLCJkb2N1bWVudEVsZW1lbnQiLCJzZXRQcm90b3R5cGVPZiIsInVuIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJJdGVyYXRvcnMiLCJmbG9vciIsImlzSW50ZWdlciIsImlzUmVnRXhwIiwicmV0IiwiZGVzY3JpcHRvciIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiTElCUkFSWSIsIiRpdGVyQ3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJCVUdHWSIsImtleXMiLCJGRl9JVEVSQVRPUiIsIktFWVMiLCJWQUxVRVMiLCJyZXR1cm5UaGlzIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsIkRFRl9WQUxVRVMiLCJWQUxVRVNfQlVHIiwiJG5hdGl2ZSIsIiRkZWZhdWx0IiwiJGVudHJpZXMiLCIkYW55TmF0aXZlIiwiU0FGRV9DTE9TSU5HIiwicml0ZXIiLCJza2lwQ2xvc2luZyIsInNhZmUiLCJhcnIiLCIkZXhwbTEiLCJleHBtMSIsIngiLCJzaWduIiwicG93IiwiRVBTSUxPTiIsIkVQU0lMT04zMiIsIk1BWDMyIiwiTUlOMzIiLCJyb3VuZFRpZXNUb0V2ZW4iLCJmcm91bmQiLCIkYWJzIiwiJHNpZ24iLCJJbmZpbml0eSIsImxvZzFwIiwibG9nIiwiTUVUQSIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJ3Iiwib25GcmVlemUiLCJtYWNyb3Rhc2siLCJPYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwicHJvY2VzcyIsImlzTm9kZSIsImhlYWQiLCJsYXN0Iiwibm90aWZ5IiwiZmx1c2giLCJwYXJlbnQiLCJkb21haW4iLCJleGl0IiwiZW50ZXIiLCJuZXh0VGljayIsIm5hdmlnYXRvciIsInN0YW5kYWxvbmUiLCJ0b2dnbGUiLCJub2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInJlc29sdmUiLCJwcm9taXNlIiwidGhlbiIsInRhc2siLCJQcm9taXNlQ2FwYWJpbGl0eSIsInJlamVjdCIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwiJGFzc2lnbiIsImFzc2lnbiIsIkEiLCJTeW1ib2wiLCJLIiwiaiIsImRQcyIsImVudW1CdWdLZXlzIiwiSUVfUFJPVE8iLCJFbXB0eSIsImNyZWF0ZURpY3QiLCJpZnJhbWUiLCJsdCIsImd0IiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwid3JpdGUiLCJjbG9zZSIsIlByb3BlcnRpZXMiLCJJRThfRE9NX0RFRklORSIsIkF0dHJpYnV0ZXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdPUE4iLCJ3aW5kb3dOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRXaW5kb3dOYW1lcyIsIiRrZXlzIiwiaGlkZGVuS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdFByb3RvIiwiYXJyYXlJbmRleE9mIiwibmFtZXMiLCJpc0VudHJpZXMiLCJSZWZsZWN0Iiwib3duS2V5cyIsIiRwYXJzZUZsb2F0IiwicGFyc2VGbG9hdCIsIiR0cmltIiwidHJpbSIsImNoYXJBdCIsIiRwYXJzZUludCIsInBhcnNlSW50Iiwid3MiLCJoZXgiLCJyYWRpeCIsInRlc3QiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSIsInByb21pc2VDYXBhYmlsaXR5IiwiYml0bWFwIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiU1JDIiwiJHRvU3RyaW5nIiwiVE9fU1RSSU5HIiwiVFBMIiwiaW5zcGVjdFNvdXJjZSIsImlzRnVuY3Rpb24iLCJjbGFzc29mIiwiYnVpbHRpbkV4ZWMiLCJyZWdleHBGbGFncyIsIm5hdGl2ZUV4ZWMiLCJuYXRpdmVSZXBsYWNlIiwicGF0Y2hlZEV4ZWMiLCJMQVNUX0lOREVYIiwiVVBEQVRFU19MQVNUX0lOREVYX1dST05HIiwicmUxIiwicmUyIiwiTlBDR19JTkNMVURFRCIsIlBBVENIIiwibGFzdEluZGV4IiwicmVDb3B5IiwibWF0Y2giLCJjaGVjayIsImJ1Z2d5IiwiX19wcm90b19fIiwidGFnIiwic3RhdCIsInNoYXJlZCIsInVpZCIsIlNIQVJFRCIsIm1vZGUiLCJjb3B5cmlnaHQiLCJEIiwibWV0aG9kIiwidG9JbnRlZ2VyIiwicG9zIiwibCIsImNoYXJDb2RlQXQiLCJzZWFyY2hTdHJpbmciLCJxdW90IiwiY3JlYXRlSFRNTCIsImF0dHJpYnV0ZSIsInAxIiwidG9Mb3dlckNhc2UiLCJyZXBlYXQiLCJtYXhMZW5ndGgiLCJmaWxsU3RyaW5nIiwibGVmdCIsInN0cmluZ0xlbmd0aCIsImZpbGxTdHIiLCJpbnRNYXhMZW5ndGgiLCJmaWxsTGVuIiwic3RyaW5nRmlsbGVyIiwiY2VpbCIsInNwYWNlcyIsInNwYWNlIiwibm9uIiwibHRyaW0iLCJydHJpbSIsImV4cG9ydGVyIiwiQUxJQVMiLCJGT1JDRSIsImh0bWwiLCJjZWwiLCJzZXRUYXNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsIkRpc3BhdGNoIiwiY291bnRlciIsInF1ZXVlIiwiT05SRUFEWVNUQVRFQ0hBTkdFIiwiZGVmZXIiLCJjaGFubmVsIiwicG9ydCIsInJ1biIsImxpc3RlbmVyIiwiZXZlbnQiLCJub3ciLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsIm1heCIsIm51bWJlciIsImlzTmFOIiwidmFsdWVPZiIsIiR0eXBlZCIsIiRidWZmZXIiLCJwcm9wZXJ0eURlc2MiLCJ0b0luZGV4IiwiY3JlYXRlQXJyYXlJbmNsdWRlcyIsIkFycmF5SXRlcmF0b3JzIiwiYXJyYXlGaWxsIiwiYXJyYXlDb3B5V2l0aGluIiwiJERQIiwiJEdPUEQiLCJVaW50OEFycmF5IiwiQVJSQVlfQlVGRkVSIiwiU0hBUkVEX0JVRkZFUiIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiJEFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCIkRGF0YVZpZXciLCJEYXRhVmlldyIsImFycmF5Rm9yRWFjaCIsImFycmF5RmlsdGVyIiwiYXJyYXlTb21lIiwiYXJyYXlFdmVyeSIsImFycmF5SW5jbHVkZXMiLCJhcnJheVZhbHVlcyIsImFycmF5S2V5cyIsImFycmF5RW50cmllcyIsImFycmF5TGFzdEluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFycmF5UmVkdWNlIiwicmVkdWNlIiwiYXJyYXlSZWR1Y2VSaWdodCIsInJlZHVjZVJpZ2h0IiwiYXJyYXlKb2luIiwiYXJyYXlTb3J0Iiwic29ydCIsImFycmF5VG9TdHJpbmciLCJhcnJheVRvTG9jYWxlU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJUWVBFRF9DT05TVFJVQ1RPUiIsIkRFRl9DT05TVFJVQ1RPUiIsIkFMTF9DT05TVFJVQ1RPUlMiLCJDT05TVFIiLCJUWVBFRF9BUlJBWSIsIlRZUEVEIiwiVklFVyIsIldST05HX0xFTkdUSCIsIiRtYXAiLCJhbGxvY2F0ZSIsIkxJVFRMRV9FTkRJQU4iLCJVaW50MTZBcnJheSIsImJ1ZmZlciIsIkZPUkNFRF9TRVQiLCJ0b09mZnNldCIsIkJZVEVTIiwib2Zmc2V0Iiwic3BlY2llc0Zyb21MaXN0IiwibGlzdCIsImZyb21MaXN0IiwiYWRkR2V0dGVyIiwiaW50ZXJuYWwiLCJfZCIsIiRmcm9tIiwibWFwZm4iLCJtYXBwaW5nIiwiJG9mIiwib2YiLCJUT19MT0NBTEVfQlVHIiwiJHRvTG9jYWxlU3RyaW5nIiwiZXZlcnkiLCJmaWx0ZXIiLCJmaW5kIiwicHJlZGljYXRlIiwiZmluZEluZGV4IiwiaW5kZXhPZiIsInNlYXJjaEVsZW1lbnQiLCJzZXBhcmF0b3IiLCJtYXAiLCJyZXZlcnNlIiwibWlkZGxlIiwic29tZSIsImNvbXBhcmVmbiIsInN1YmFycmF5IiwiYmVnaW4iLCIkYmVnaW4iLCJieXRlT2Zmc2V0IiwiJHNsaWNlIiwiJHNldCIsImFycmF5TGlrZSIsIiRpdGVyYXRvcnMiLCJpc1RBSW5kZXgiLCIkZ2V0RGVzYyIsIiRzZXREZXNjIiwiZGVzYyIsIiRUeXBlZEFycmF5UHJvdG90eXBlJCIsIkNMQU1QRUQiLCJHRVRURVIiLCJTRVRURVIiLCJUeXBlZEFycmF5IiwiVEFDIiwiQUJWIiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdldHRlciIsIm8iLCJzZXR0ZXIiLCJyb3VuZCIsImFkZEVsZW1lbnQiLCIkb2Zmc2V0IiwiJGxlbmd0aCIsImJ5dGVMZW5ndGgiLCJrbGFzcyIsIiRsZW4iLCIkbmF0aXZlSXRlcmF0b3IiLCJDT1JSRUNUX0lURVJfTkFNRSIsIiRpdGVyYXRvciIsIkRBVEFfVklFVyIsIldST05HX0lOREVYIiwiQmFzZUJ1ZmZlciIsIkxOMiIsIkJVRkZFUiIsIkJZVEVfTEVOR1RIIiwiQllURV9PRkZTRVQiLCIkQlVGRkVSIiwiJExFTkdUSCIsIiRPRkZTRVQiLCJwYWNrSUVFRTc1NCIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwicnQiLCJ1bnBhY2tJRUVFNzU0IiwibkJpdHMiLCJ1bnBhY2tJMzIiLCJieXRlcyIsInBhY2tJOCIsInBhY2tJMTYiLCJwYWNrSTMyIiwicGFja0Y2NCIsInBhY2tGMzIiLCJ2aWV3IiwiaXNMaXR0bGVFbmRpYW4iLCJudW1JbmRleCIsImludEluZGV4IiwiX2IiLCJwYWNrIiwiY29udmVyc2lvbiIsImJ1ZmZlckxlbmd0aCIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEludDgiLCJzZXRVaW50OCIsInNldEludDE2Iiwic2V0VWludDE2Iiwic2V0SW50MzIiLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwic2V0RmxvYXQ2NCIsIkFycmF5QnVmZmVyUHJvdG8iLCIkc2V0SW50OCIsIlR5cGVkIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9ycyIsInB4IiwicmFuZG9tIiwidXNlckFnZW50Iiwid2tzRXh0IiwiJFN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsImdldEl0ZXJhdG9yTWV0aG9kIiwiJGV2ZXJ5IiwiJGZpbHRlciIsIiRmaW5kIiwiZm9yY2VkIiwiJGZvckVhY2giLCJTVFJJQ1QiLCJjcmVhdGVQcm9wZXJ0eSIsIiRpbmRleE9mIiwiTkVHQVRJVkVfWkVSTyIsImFkZFRvVW5zY29wYWJsZXMiLCJBcmd1bWVudHMiLCIkcmVkdWNlIiwidXBUbyIsInNpemUiLCJjbG9uZWQiLCIkc29tZSIsIiRzb3J0IiwidG9KU09OIiwicHYiLCJUT19QUklNSVRJVkUiLCJEYXRlUHJvdG8iLCJJTlZBTElEX0RBVEUiLCJIQVNfSU5TVEFOQ0UiLCJGdW5jdGlvblByb3RvIiwiRlByb3RvIiwibmFtZVJFIiwic3Ryb25nIiwiTUFQIiwiTWFwIiwic3FydCIsIiRhY29zaCIsImFjb3NoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiJGFzaW5oIiwiYXNpbmgiLCIkYXRhbmgiLCJhdGFuaCIsImNicnQiLCJjbHozMiIsIkxPRzJFIiwiY29zaCIsImh5cG90IiwidmFsdWUxIiwidmFsdWUyIiwic3VtIiwibGFyZyIsImRpdiIsIiRpbXVsIiwiaW11bCIsIlVJTlQxNiIsInhuIiwieW4iLCJ4bCIsInlsIiwibG9nMTAiLCJMT0cxMEUiLCJsb2cyIiwic2luaCIsIkUiLCJ0YW5oIiwidHJ1bmMiLCIkTnVtYmVyIiwiQlJPS0VOX0NPRiIsIlRSSU0iLCJ0b051bWJlciIsImFyZ3VtZW50IiwiZmlyc3QiLCJ0aGlyZCIsIm1heENvZGUiLCJkaWdpdHMiLCJjb2RlIiwiX2lzRmluaXRlIiwiaXNTYWZlSW50ZWdlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiYU51bWJlclZhbHVlIiwiJHRvRml4ZWQiLCJ0b0ZpeGVkIiwiRVJST1IiLCJaRVJPIiwibXVsdGlwbHkiLCJjMiIsImRpdmlkZSIsIm51bVRvU3RyaW5nIiwidCIsImFjYyIsIngyIiwiZnJhY3Rpb25EaWdpdHMiLCJ6IiwiJGZhaWxzIiwiJHRvUHJlY2lzaW9uIiwidG9QcmVjaXNpb24iLCJwcmVjaXNpb24iLCIkZnJlZXplIiwiZnJlZXplIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRQcm90b3R5cGVPZiIsIiRpc0V4dGVuc2libGUiLCIkaXNGcm96ZW4iLCJpc0Zyb3plbiIsIiRpc1NlYWxlZCIsImlzU2VhbGVkIiwiJHByZXZlbnRFeHRlbnNpb25zIiwiJHNlYWwiLCJzZWFsIiwibWljcm90YXNrIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJwZXJmb3JtIiwicHJvbWlzZVJlc29sdmUiLCJQUk9NSVNFIiwidmVyc2lvbnMiLCJ2OCIsIiRQcm9taXNlIiwiZW1wdHkiLCJJbnRlcm5hbCIsIm5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiV3JhcHBlciIsIlVTRV9OQVRJVkUiLCJGYWtlUHJvbWlzZSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsImlzVGhlbmFibGUiLCJpc1JlamVjdCIsIl9uIiwiY2hhaW4iLCJfYyIsIl92Iiwib2siLCJfcyIsInJlYWN0aW9uIiwiaGFuZGxlciIsImZhaWwiLCJleGl0ZWQiLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwib25VbmhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJpc1VuaGFuZGxlZCIsImVtaXQiLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsInJlYXNvbiIsImVycm9yIiwiX2EiLCJvbnJlamVjdGlvbmhhbmRsZWQiLCIkcmVqZWN0IiwiX3ciLCIkcmVzb2x2ZSIsImV4ZWN1dG9yIiwiZXJyIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2FwYWJpbGl0eSIsImFsbCIsInJlbWFpbmluZyIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwickFwcGx5IiwiZkFwcGx5IiwidGhpc0FyZ3VtZW50IiwiYXJndW1lbnRzTGlzdCIsIkwiLCJyQ29uc3RydWN0IiwiTkVXX1RBUkdFVF9CVUciLCJBUkdTX0JVRyIsIlRhcmdldCIsIm5ld1RhcmdldCIsIiRhcmdzIiwicHJvcGVydHlLZXkiLCJhdHRyaWJ1dGVzIiwiZGVsZXRlUHJvcGVydHkiLCJFbnVtZXJhdGUiLCJlbnVtZXJhdGUiLCJnZXRQcm90byIsInJlY2VpdmVyIiwic2V0UHJvdG8iLCJWIiwib3duRGVzYyIsImV4aXN0aW5nRGVzY3JpcHRvciIsIiRmbGFncyIsIiRSZWdFeHAiLCJDT1JSRUNUX05FVyIsInRpUkUiLCJwaVJFIiwiZmlVIiwicHJveHkiLCJmbGFncyIsImFkdmFuY2VTdHJpbmdJbmRleCIsInJlZ0V4cEV4ZWMiLCIkbWF0Y2giLCJyeCIsImZ1bGxVbmljb2RlIiwibWF0Y2hTdHIiLCJTVUJTVElUVVRJT05fU1lNQk9MUyIsIlNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEIiwibWF5YmVUb1N0cmluZyIsIlJFUExBQ0UiLCIkcmVwbGFjZSIsInNlYXJjaFZhbHVlIiwicmVwbGFjZVZhbHVlIiwiZnVuY3Rpb25hbFJlcGxhY2UiLCJyZXN1bHRzIiwiYWNjdW11bGF0ZWRSZXN1bHQiLCJuZXh0U291cmNlUG9zaXRpb24iLCJtYXRjaGVkIiwicG9zaXRpb24iLCJjYXB0dXJlcyIsIm5hbWVkQ2FwdHVyZXMiLCJyZXBsYWNlckFyZ3MiLCJyZXBsYWNlbWVudCIsImdldFN1YnN0aXR1dGlvbiIsInRhaWxQb3MiLCJjaCIsImNhcHR1cmUiLCJzYW1lVmFsdWUiLCJTRUFSQ0giLCIkc2VhcmNoIiwic2VhcmNoIiwicHJldmlvdXNMYXN0SW5kZXgiLCJjYWxsUmVnRXhwRXhlYyIsIiRtaW4iLCIkcHVzaCIsIiRTUExJVCIsIkxFTkdUSCIsIk1BWF9VSU5UMzIiLCJTVVBQT1JUU19ZIiwiU1BMSVQiLCIkc3BsaXQiLCJpbnRlcm5hbFNwbGl0IiwibGltaXQiLCJvdXRwdXQiLCJsYXN0TGFzdEluZGV4Iiwic3BsaXRMaW1pdCIsInNlcGFyYXRvckNvcHkiLCJsYXN0TGVuZ3RoIiwic3BsaXR0ZXIiLCJ1bmljb2RlTWF0Y2hpbmciLCJsaW0iLCJxIiwiZGVmaW5lIiwiU0VUIiwiU2V0IiwiYW5jaG9yIiwiYmlnIiwiYmxpbmsiLCJib2xkIiwiJGF0IiwiY29kZVBvaW50QXQiLCJjb250ZXh0IiwiRU5EU19XSVRIIiwiJGVuZHNXaXRoIiwiZW5kc1dpdGgiLCJlbmRQb3NpdGlvbiIsImZpeGVkIiwiZm9udGNvbG9yIiwiY29sb3IiLCJmb250c2l6ZSIsImZyb21DaGFyQ29kZSIsIiRmcm9tQ29kZVBvaW50IiwiZnJvbUNvZGVQb2ludCIsIklOQ0xVREVTIiwiaXRhbGljcyIsInBvaW50IiwibGluayIsInVybCIsInJhdyIsImNhbGxTaXRlIiwidHBsIiwic21hbGwiLCJTVEFSVFNfV0lUSCIsIiRzdGFydHNXaXRoIiwic3RhcnRzV2l0aCIsInN0cmlrZSIsInN1YiIsInN1cCIsIndrc0RlZmluZSIsImVudW1LZXlzIiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkSlNPTiIsIkpTT04iLCJfc3RyaW5naWZ5Iiwic3RyaW5naWZ5IiwiSElEREVOIiwiU3ltYm9sUmVnaXN0cnkiLCJBbGxTeW1ib2xzIiwiT1BTeW1ib2xzIiwiUU9iamVjdCIsImZpbmRDaGlsZCIsInNldFN5bWJvbERlc2MiLCJwcm90b0Rlc2MiLCJ3cmFwIiwic3ltIiwiaXNTeW1ib2wiLCIkZGVmaW5lUHJvcGVydGllcyIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIklTX09QIiwiZXM2U3ltYm9scyIsIndlbGxLbm93blN5bWJvbHMiLCJrZXlGb3IiLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJyZXBsYWNlciIsIiRyZXBsYWNlciIsIiRpc1ZpZXciLCJpc1ZpZXciLCJmaW4iLCJ2aWV3UyIsInZpZXdUIiwiaW5pdCIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiSW50OEFycmF5IiwiVWludDMyQXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsImVhY2giLCJ3ZWFrIiwiTkFUSVZFX1dFQUtfTUFQIiwiSVNfSUUxMSIsIkFjdGl2ZVhPYmplY3QiLCJXRUFLX01BUCIsIkludGVybmFsTWFwIiwiV2Vha01hcCIsIiRXZWFrTWFwIiwiV0VBS19TRVQiLCJXZWFrU2V0IiwiJGluY2x1ZGVzIiwiZ2V0RGVzYyIsIiR2YWx1ZXMiLCJvbkZpbmFsbHkiLCIkcGFkIiwiV0VCS0lUX0JVRyIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwiY29sbGVjdGlvbnMiLCJleHBsaWNpdCIsIkNvbGxlY3Rpb24iLCIkdGFzayIsIk1TSUUiLCJ0aW1lIiwiYm91bmRBcmdzIiwic2V0SW50ZXJ2YWwiLCJWRVJTSU9OIiwiTEFSR0VfQVJSQVlfU0laRSIsIkNPUkVfRVJST1JfVEVYVCIsIkZVTkNfRVJST1JfVEVYVCIsIkhBU0hfVU5ERUZJTkVEIiwiTUFYX01FTU9JWkVfU0laRSIsIlBMQUNFSE9MREVSIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfRkxBVF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiREVGQVVMVF9UUlVOQ19MRU5HVEgiLCJERUZBVUxUX1RSVU5DX09NSVNTSU9OIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJMQVpZX0ZJTFRFUl9GTEFHIiwiTEFaWV9NQVBfRkxBRyIsIkxBWllfV0hJTEVfRkxBRyIsIklORklOSVRZIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYXN5bmNUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImRvbUV4Y1RhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm51bGxUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicHJveHlUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJ1bmRlZmluZWRUYWciLCJ3ZWFrTWFwVGFnIiwid2Vha1NldFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzY2FwZWRIdG1sIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNFc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlSW50ZXJwb2xhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwicmVQcm9wTmFtZSIsInJlUmVnRXhwQ2hhciIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbSIsInJlVHJpbVN0YXJ0IiwicmVUcmltRW5kIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxIiwicnNFbW9qaSIsInJzU3ltYm9sIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGUiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsInR5cGVkQXJyYXlUYWdzIiwiY2xvbmVhYmxlVGFncyIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsImZyZWVQYXJzZUludCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJmcmVlUHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJiaW5kaW5nIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwibm9kZUlzU2V0IiwiaXNTZXQiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiZnVuYyIsInRoaXNBcmciLCJhcnJheUFnZ3JlZ2F0b3IiLCJhcnJheSIsIml0ZXJhdGVlIiwiYWNjdW11bGF0b3IiLCJhcnJheUVhY2giLCJhcnJheUVhY2hSaWdodCIsInJlc0luZGV4IiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJhcnJheU1hcCIsImFycmF5UHVzaCIsImluaXRBY2N1bSIsImFzY2lpU2l6ZSIsImJhc2VQcm9wZXJ0eSIsImFzY2lpVG9BcnJheSIsImFzY2lpV29yZHMiLCJiYXNlRmluZEtleSIsImNvbGxlY3Rpb24iLCJlYWNoRnVuYyIsImJhc2VGaW5kSW5kZXgiLCJmcm9tUmlnaHQiLCJzdHJpY3RJbmRleE9mIiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2ZXaXRoIiwiYmFzZU1lYW4iLCJiYXNlU3VtIiwiYmFzZVByb3BlcnR5T2YiLCJiYXNlUmVkdWNlIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwiY3VycmVudCIsImJhc2VUaW1lcyIsImJhc2VUb1BhaXJzIiwicHJvcHMiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjYWNoZSIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwiaGFzVW5pY29kZVdvcmQiLCJpdGVyYXRvclRvQXJyYXkiLCJtYXBUb0FycmF5Iiwib3ZlckFyZyIsInRyYW5zZm9ybSIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9BcnJheSIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsInVuZXNjYXBlSHRtbENoYXIiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJfIiwiZGVmYXVsdHMiLCJwaWNrIiwiRXJyb3IiLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwiaWRDb3VudGVyIiwibWFza1NyY0tleSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJyZUlzTmF0aXZlIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJnZXRQcm90b3R5cGUiLCJvYmplY3RDcmVhdGUiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic3ltSXRlcmF0b3IiLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0TmF0aXZlIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsIm5hdGl2ZUNlaWwiLCJuYXRpdmVGbG9vciIsIm5hdGl2ZUdldFN5bWJvbHMiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwibmF0aXZlSXNGaW5pdGUiLCJuYXRpdmVKb2luIiwibmF0aXZlS2V5cyIsIm5hdGl2ZU1heCIsIm5hdGl2ZU1pbiIsIm5hdGl2ZU5vdyIsIm5hdGl2ZVBhcnNlSW50IiwibmF0aXZlUmFuZG9tIiwibmF0aXZlUmV2ZXJzZSIsIm5hdGl2ZUNyZWF0ZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsInN5bWJvbFRvU3RyaW5nIiwibG9kYXNoIiwiaXNPYmplY3RMaWtlIiwiTGF6eVdyYXBwZXIiLCJMb2Rhc2hXcmFwcGVyIiwid3JhcHBlckNsb25lIiwiYmFzZUNyZWF0ZSIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsIl9fZGlyX18iLCJfX2ZpbHRlcmVkX18iLCJfX2l0ZXJhdGVlc19fIiwiX190YWtlQ291bnRfXyIsIl9fdmlld3NfXyIsImxhenlDbG9uZSIsImNvcHlBcnJheSIsImxhenlSZXZlcnNlIiwiY2xvbmUiLCJsYXp5VmFsdWUiLCJkaXIiLCJpc0FyciIsImFyckxlbmd0aCIsImdldFZpZXciLCJpdGVyYXRlZXMiLCJpdGVyTGVuZ3RoIiwidGFrZUNvdW50IiwiYmFzZVdyYXBwZXJWYWx1ZSIsIm91dGVyIiwiaXRlckluZGV4IiwiY29tcHV0ZWQiLCJIYXNoIiwiaGFzaENsZWFyIiwiX19kYXRhX18iLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiTGlzdENhY2hlIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJhc3NvY0luZGV4T2YiLCJwb3AiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJNYXBDYWNoZSIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsImdldE1hcERhdGEiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJTZXRDYWNoZSIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTdGFjayIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsInBhaXJzIiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJnIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImlzSW5kZXgiLCJhcnJheVNhbXBsZSIsImJhc2VSYW5kb20iLCJhcnJheVNhbXBsZVNpemUiLCJzaHVmZmxlU2VsZiIsImJhc2VDbGFtcCIsImFycmF5U2h1ZmZsZSIsImFzc2lnbk1lcmdlVmFsdWUiLCJlcSIsImJhc2VBc3NpZ25WYWx1ZSIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJiYXNlQWdncmVnYXRvciIsImJhc2VFYWNoIiwiYmFzZUFzc2lnbiIsImNvcHlPYmplY3QiLCJiYXNlQXNzaWduSW4iLCJrZXlzSW4iLCJiYXNlQXQiLCJwYXRocyIsInNraXAiLCJsb3dlciIsInVwcGVyIiwiYmFzZUNsb25lIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJzdGFjayIsImlzRGVlcCIsImlzRmxhdCIsImlzRnVsbCIsImluaXRDbG9uZUFycmF5IiwiZ2V0VGFnIiwiaXNGdW5jIiwiY2xvbmVCdWZmZXIiLCJpbml0Q2xvbmVPYmplY3QiLCJjb3B5U3ltYm9sc0luIiwiY29weVN5bWJvbHMiLCJpbml0Q2xvbmVCeVRhZyIsInN0YWNrZWQiLCJzdWJWYWx1ZSIsImtleXNGdW5jIiwiZ2V0QWxsS2V5c0luIiwiZ2V0QWxsS2V5cyIsImJhc2VDb25mb3JtcyIsImJhc2VDb25mb3Jtc1RvIiwiYmFzZURlbGF5Iiwid2FpdCIsImJhc2VEaWZmZXJlbmNlIiwiaXNDb21tb24iLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJiYXNlRmlsbCIsImJhc2VGaWx0ZXIiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNTdHJpY3QiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZvciIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yUmlnaHQiLCJiYXNlRnVuY3Rpb25zIiwiYmFzZUdldCIsInBhdGgiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImJhc2VHZXRUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImJhc2VHdCIsIm90aGVyIiwiYmFzZUhhcyIsImJhc2VIYXNJbiIsImJhc2VJblJhbmdlIiwiYmFzZUludGVyc2VjdGlvbiIsImFycmF5cyIsIm90aExlbmd0aCIsIm90aEluZGV4IiwiY2FjaGVzIiwic2VlbiIsImJhc2VJbnZlcnRlciIsImJhc2VJbnZva2UiLCJiYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNFcXVhbCIsImJhc2VJc0VxdWFsRGVlcCIsImVxdWFsRnVuYyIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiZXF1YWxPYmplY3RzIiwiYmFzZUlzTWFwIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJzcmNWYWx1ZSIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsImJhc2VJc1JlZ0V4cCIsImJhc2VJc1NldCIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc0xlbmd0aCIsImJhc2VJdGVyYXRlZSIsImlkZW50aXR5IiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VNYXRjaGVzIiwicHJvcGVydHkiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTHQiLCJiYXNlTWFwIiwiaXNBcnJheUxpa2UiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImlzS2V5IiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJuZXdWYWx1ZSIsInNhZmVHZXQiLCJtZXJnZUZ1bmMiLCJpc1R5cGVkIiwiaXNBcnJheUxpa2VPYmplY3QiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImJhc2VOdGgiLCJiYXNlT3JkZXJCeSIsIm9yZGVycyIsImdldEl0ZXJhdGVlIiwiY3JpdGVyaWEiLCJjb21wYXJlTXVsdGlwbGUiLCJiYXNlUGljayIsImJhc2VQaWNrQnkiLCJiYXNlU2V0IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsImJhc2VSZXBlYXQiLCJiYXNlUmVzdCIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJiYXNlU2FtcGxlIiwiYmFzZVNhbXBsZVNpemUiLCJuZXN0ZWQiLCJiYXNlU2V0RGF0YSIsImJhc2VTZXRUb1N0cmluZyIsImNvbnN0YW50IiwiYmFzZVNodWZmbGUiLCJiYXNlU2xpY2UiLCJiYXNlU29tZSIsImJhc2VTb3J0ZWRJbmRleCIsInJldEhpZ2hlc3QiLCJsb3ciLCJoaWdoIiwibWlkIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiYmFzZVNvcnRlZFVuaXEiLCJiYXNlVG9OdW1iZXIiLCJiYXNlVG9TdHJpbmciLCJiYXNlVW5pcSIsImNyZWF0ZVNldCIsInNlZW5JbmRleCIsImJhc2VVcGRhdGUiLCJ1cGRhdGVyIiwiYmFzZVdoaWxlIiwiaXNEcm9wIiwiYWN0aW9ucyIsImFjdGlvbiIsImJhc2VYb3IiLCJiYXNlWmlwT2JqZWN0IiwiYXNzaWduRnVuYyIsInZhbHNMZW5ndGgiLCJjYXN0QXJyYXlMaWtlT2JqZWN0IiwiY2FzdEZ1bmN0aW9uIiwic3RyaW5nVG9QYXRoIiwiY2FzdFJlc3QiLCJjYXN0U2xpY2UiLCJjb3B5IiwiY2xvbmVBcnJheUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiY2xvbmVEYXRhVmlldyIsImRhdGFWaWV3IiwiY2xvbmVSZWdFeHAiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiaXNOZXciLCJnZXRTeW1ib2xzSW4iLCJjcmVhdGVBZ2dyZWdhdG9yIiwiaW5pdGlhbGl6ZXIiLCJjcmVhdGVBc3NpZ25lciIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwiaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiQ3RvciIsImNyZWF0ZUN0b3IiLCJjcmVhdGVDYXNlRmlyc3QiLCJtZXRob2ROYW1lIiwidHJhaWxpbmciLCJjcmVhdGVDb21wb3VuZGVyIiwiY2FsbGJhY2siLCJ3b3JkcyIsImRlYnVyciIsInRoaXNCaW5kaW5nIiwiY3JlYXRlQ3VycnkiLCJhcml0eSIsImdldEhvbGRlciIsImNyZWF0ZVJlY3VycnkiLCJjcmVhdGVIeWJyaWQiLCJjcmVhdGVGaW5kIiwiZmluZEluZGV4RnVuYyIsImNyZWF0ZUZsb3ciLCJmbGF0UmVzdCIsImZ1bmNzIiwicHJlcmVxIiwidGhydSIsImdldEZ1bmNOYW1lIiwiZnVuY05hbWUiLCJnZXREYXRhIiwiaXNMYXppYWJsZSIsInBsYW50IiwicGFydGlhbHNSaWdodCIsImhvbGRlcnNSaWdodCIsImFyZ1BvcyIsImFyeSIsImlzQXJ5IiwiaXNCaW5kS2V5IiwiaXNGbGlwIiwiaG9sZGVyc0NvdW50IiwibmV3SG9sZGVycyIsInJlb3JkZXIiLCJjcmVhdGVJbnZlcnRlciIsInRvSXRlcmF0ZWUiLCJjcmVhdGVNYXRoT3BlcmF0aW9uIiwib3BlcmF0b3IiLCJkZWZhdWx0VmFsdWUiLCJjcmVhdGVPdmVyIiwiYXJyYXlGdW5jIiwiY3JlYXRlUGFkZGluZyIsImNoYXJzIiwiY2hhcnNMZW5ndGgiLCJjcmVhdGVQYXJ0aWFsIiwiY3JlYXRlUmFuZ2UiLCJ0b0Zpbml0ZSIsImNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24iLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicGFpciIsIm5vb3AiLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJjdXN0b21EZWZhdWx0c01lcmdlIiwiY3VzdG9tT21pdENsb25lIiwiaXNQYXJ0aWFsIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwibWVzc2FnZSIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsImZsYXR0ZW4iLCJvdGhlckZ1bmMiLCJpc0tleWFibGUiLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwiY3RvclN0cmluZyIsInRyYW5zZm9ybXMiLCJnZXRXcmFwRGV0YWlscyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiaW5wdXQiLCJpbnNlcnRXcmFwRGV0YWlscyIsImRldGFpbHMiLCJpc01hc2thYmxlIiwic3R1YkZhbHNlIiwibWVtb2l6ZUNhcHBlZCIsIm1lbW9pemUiLCJzcmNCaXRtYXNrIiwibmV3Qml0bWFzayIsImlzQ29tYm8iLCJvdGhlckFyZ3MiLCJvbGRBcnJheSIsInNob3J0T3V0IiwicmVmZXJlbmNlIiwidXBkYXRlV3JhcERldGFpbHMiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyYW5kIiwicXVvdGUiLCJzdWJTdHJpbmciLCJjaHVuayIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZGlmZmVyZW5jZUJ5IiwiZGlmZmVyZW5jZVdpdGgiLCJkcm9wIiwiZHJvcFJpZ2h0IiwiZHJvcFJpZ2h0V2hpbGUiLCJkcm9wV2hpbGUiLCJmaW5kTGFzdEluZGV4IiwiZmxhdHRlbkRlZXAiLCJmbGF0dGVuRGVwdGgiLCJmcm9tUGFpcnMiLCJpbml0aWFsIiwiaW50ZXJzZWN0aW9uIiwibWFwcGVkIiwiaW50ZXJzZWN0aW9uQnkiLCJpbnRlcnNlY3Rpb25XaXRoIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInJlbW92ZSIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwidGFwIiwiaW50ZXJjZXB0b3IiLCJ3cmFwcGVyQXQiLCJ3cmFwcGVyQ2hhaW4iLCJ3cmFwcGVyQ29tbWl0Iiwid3JhcHBlck5leHQiLCJ0b0FycmF5Iiwid3JhcHBlclRvSXRlcmF0b3IiLCJ3cmFwcGVyUGxhbnQiLCJ3cmFwcGVyUmV2ZXJzZSIsIndyYXBwZWQiLCJ3cmFwcGVyVmFsdWUiLCJjb3VudEJ5IiwiZmluZExhc3QiLCJmbGF0TWFwIiwiZmxhdE1hcERlZXAiLCJmbGF0TWFwRGVwdGgiLCJmb3JFYWNoUmlnaHQiLCJncm91cEJ5IiwiaXNTdHJpbmciLCJpbnZva2VNYXAiLCJrZXlCeSIsIm9yZGVyQnkiLCJwYXJ0aXRpb24iLCJuZWdhdGUiLCJzYW1wbGUiLCJzYW1wbGVTaXplIiwic2h1ZmZsZSIsInNvcnRCeSIsImFmdGVyIiwiYmVmb3JlIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwib3B0aW9ucyIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsImludm9rZUZ1bmMiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWxheSIsImZsaXAiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJvbmNlIiwib3ZlckFyZ3MiLCJmdW5jc0xlbmd0aCIsInBhcnRpYWwiLCJwYXJ0aWFsUmlnaHQiLCJyZWFyZyIsInJlc3QiLCJzcHJlYWQiLCJ0aHJvdHRsZSIsInVuYXJ5IiwiY2FzdEFycmF5IiwiY2xvbmVXaXRoIiwiY2xvbmVEZWVwIiwiY2xvbmVEZWVwV2l0aCIsImNvbmZvcm1zVG8iLCJndGUiLCJpc0Jvb2xlYW4iLCJpc0VsZW1lbnQiLCJpc0VtcHR5IiwiaXNFcXVhbCIsImlzRXF1YWxXaXRoIiwiaXNFcnJvciIsImlzTWF0Y2giLCJpc01hdGNoV2l0aCIsImlzTnVtYmVyIiwiaXNOYXRpdmUiLCJpc051bGwiLCJpc05pbCIsImlzVW5kZWZpbmVkIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHRlIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwicHJvcGVydGllcyIsInByb3BzSW5kZXgiLCJwcm9wc0xlbmd0aCIsImRlZmF1bHRzRGVlcCIsIm1lcmdlV2l0aCIsImZpbmRLZXkiLCJmaW5kTGFzdEtleSIsImZvckluIiwiZm9ySW5SaWdodCIsImZvck93biIsImZvck93blJpZ2h0IiwiZnVuY3Rpb25zIiwiZnVuY3Rpb25zSW4iLCJpbnZlcnQiLCJpbnZlcnRCeSIsIm1hcEtleXMiLCJtYXBWYWx1ZXMiLCJtZXJnZSIsIm9taXQiLCJvbWl0QnkiLCJwaWNrQnkiLCJwcm9wIiwic2V0V2l0aCIsInRvUGFpcnMiLCJ0b1BhaXJzSW4iLCJpc0Fyckxpa2UiLCJ1bnNldCIsInVwZGF0ZSIsInVwZGF0ZVdpdGgiLCJ2YWx1ZXNJbiIsImNsYW1wIiwiaW5SYW5nZSIsImZsb2F0aW5nIiwidGVtcCIsImNhbWVsQ2FzZSIsIndvcmQiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVzY2FwZSIsImVzY2FwZVJlZ0V4cCIsImtlYmFiQ2FzZSIsImxvd2VyQ2FzZSIsImxvd2VyRmlyc3QiLCJwYWQiLCJzdHJMZW5ndGgiLCJzbmFrZUNhc2UiLCJzdGFydENhc2UiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidG9VcHBlckNhc2UiLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJvbWlzc2lvbiIsInN1YnN0cmluZyIsIm5ld0VuZCIsInVuZXNjYXBlIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2RPZiIsIm1peGluIiwibm9Db25mbGljdCIsIm50aEFyZyIsIm92ZXIiLCJvdmVyRXZlcnkiLCJvdmVyU29tZSIsInByb3BlcnR5T2YiLCJyYW5nZSIsInJhbmdlUmlnaHQiLCJzdHViT2JqZWN0Iiwic3R1YlN0cmluZyIsInN0dWJUcnVlIiwidGltZXMiLCJ0b1BhdGgiLCJ1bmlxdWVJZCIsInByZWZpeCIsImF1Z2VuZCIsImFkZGVuZCIsImRpdmlkZW5kIiwiZGl2aXNvciIsIm1heEJ5IiwibWVhbiIsIm1lYW5CeSIsIm1pbkJ5IiwibXVsdGlwbGllciIsIm11bHRpcGxpY2FuZCIsInN1YnRyYWN0IiwibWludWVuZCIsInN1YnRyYWhlbmQiLCJzdW1CeSIsImVudHJpZXNJbiIsImV4dGVuZCIsImV4dGVuZFdpdGgiLCJlYWNoUmlnaHQiLCJpc0ZpbHRlciIsInRha2VOYW1lIiwiZHJvcE5hbWUiLCJjaGVja0l0ZXJhdGVlIiwiaXNUYWtlciIsImxvZGFzaEZ1bmMiLCJyZXRVbndyYXBwZWQiLCJpc0xhenkiLCJ1c2VMYXp5IiwiaXNIeWJyaWQiLCJpc1Vud3JhcHBlZCIsIm9ubHlMYXp5IiwiY2hhaW5OYW1lIiwiY29tbWl0IiwiT3AiLCJoYXNPd24iLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJpbk1vZHVsZSIsInJ1bnRpbWUiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJpbm5lckZuIiwib3V0ZXJGbiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJDb250ZXh0IiwiX2ludm9rZSIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsIm9iaiIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsInJlY29yZCIsInVud3JhcHBlZCIsInByZXZpb3VzUHJvbWlzZSIsImVucXVldWUiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImFzeW5jIiwic3RhdGUiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJldHVybiIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmF0b3JNZXRob2QiLCJza2lwVGVtcFJlc2V0Iiwic3RvcCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwiZyIsIm9yaWdpbmFsTW9kdWxlIiwid2VicGFja1BvbHlmaWxsIiwiY2hpbGRyZW4iLCJjb21wb25lbnQiLCJlbGVtZW50IiwiYnRuIiwiaW5uZXJIVE1MIiwib25jbGljayIsInByaW50TWUiLCJib2R5Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2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QVEsQ0FBQ3M4RCxJQUFULENBQWN4eEQsV0FBZCxDQUEwQmt4RCxTQUFTLEVBQW5DLEU7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBQWUsU0FBU0ssT0FBVCxHQUFtQjtBQUNoQ3BxRSxTQUFPLENBQUNxVixHQUFSLENBQVksNkJBQVo7QUFDRCxDOzs7Ozs7Ozs7OztBQ0ZELHlDOzs7Ozs7Ozs7OztBQ0FBLHlDIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvZXM2XCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9hcnJheS9pbmNsdWRlc1wiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vc3RyaW5nL3BhZC1zdGFydFwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vc3RyaW5nL3BhZC1lbmRcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3N5bWJvbC9hc3luYy1pdGVyYXRvclwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL29iamVjdC92YWx1ZXNcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL29iamVjdC9lbnRyaWVzXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9wcm9taXNlL2ZpbmFsbHlcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3dlYlwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgY29uc29sZS53YXJuKFwiQGJhYmVsL3BvbHlmaWxsIGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZSBvbiB0aGlzIHBhZ2UuIFRoaXMgaXMgcHJvYmFibHkgbm90IGRlc2lyYWJsZS9pbnRlbmRlZCBcIiArIFwiYW5kIG1heSBoYXZlIGNvbnNlcXVlbmNlcyBpZiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgdGhlIHBvbHlmaWxscyBhcmUgYXBwbGllZCBzZXF1ZW50aWFsbHkuIFwiICsgXCJJZiB5b3UgZG8gbmVlZCB0byBsb2FkIHRoZSBwb2x5ZmlsbCBtb3JlIHRoYW4gb25jZSwgdXNlIEBiYWJlbC9wb2x5ZmlsbC9ub0NvbmZsaWN0IFwiICsgXCJpbnN0ZWFkIHRvIGJ5cGFzcyB0aGUgd2FybmluZy5cIik7XG59XG5cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJyk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuaW5jbHVkZXM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmVudHJpZXM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QudmFsdWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5Qcm9taXNlWydmaW5hbGx5J107XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3RyaW5nLnBhZEVuZDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN0cmluZy5wYWRTdGFydDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignYXN5bmNJdGVyYXRvcicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvciAoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuNScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5leGVjJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2tzKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgPyAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICB9XG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KSA6IHVuZGVmaW5lZDtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKFxuICAgICAgZGVmaW5lZCxcbiAgICAgIFNZTUJPTCxcbiAgICAgICcnW0tFWV0sXG4gICAgICBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBFUFNJTE9OID0gcG93KDIsIC01Mik7XG52YXIgRVBTSUxPTjMyID0gcG93KDIsIC0yMyk7XG52YXIgTUFYMzIgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKTtcbnZhciBNSU4zMiA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcbiAgdmFyICRhYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyICRzaWduID0gc2lnbih4KTtcbiAgdmFyIGEsIHJlc3VsdDtcbiAgaWYgKCRhYnMgPCBNSU4zMikgcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdCkgcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbn07XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG4iLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd3MgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi9fZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9IH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChuZXcgQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgU1RSSUNUID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgJG5hdGl2ZSA9IFtdLmxhc3RJbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqLykge1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPID0gdG9JT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvciAoO2luZGV4ID49IDA7IGluZGV4LS0pIGlmIChpbmRleCBpbiBPKSBpZiAoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGlmIChodG1sKSBhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmIChrbGFzcyA9PSAnQXJyYXknKSByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuKTtcbiAgICB2YXIgdXBUbyA9IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbik7XG4gICAgdmFyIHNpemUgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpO1xuICAgIHZhciBjbG9uZWQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgc2l6ZTsgaSsrKSBjbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHNvbWUgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRzb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG4iLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHsgbm93OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfSB9KTtcbiIsIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGxcbiAgICB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9IH0pICE9PSAxO1xufSksICdEYXRlJywge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcbiIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKTtcbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuXG5pZiAoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKSByZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG4iLCJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG4iLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywgeyBiaW5kOiByZXF1aXJlKCcuL19iaW5kJykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBIQVNfSU5TVEFOQ0UgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKTtcbnZhciBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZiAoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7IHZhbHVlOiBmdW5jdGlvbiAoTykge1xuICBpZiAodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSkgaWYgKHRoaXMucHJvdG90eXBlID09PSBPKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufSB9KTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGxvZzFwID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgJGFjb3NoID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU5cbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXNpbmggPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7IGFzaW5oOiBhc2luaCB9KTtcbiIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpIHtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCkge1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywgeyBleHBtMTogJGV4cG0xIH0pO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKSB9KTtcbiIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW11bCA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgeG4gPSAreDtcbiAgICB2YXIgeW4gPSAreTtcbiAgICB2YXIgeGwgPSBVSU5UMTYgJiB4bjtcbiAgICB2YXIgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgbG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKSB9KTtcbiIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKSB9KTtcbiIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyICROdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBCYXNlID0gJE51bWJlcjtcbnZhciBwcm90byA9ICROdW1iZXIucHJvdG90eXBlO1xuLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG52YXIgQlJPS0VOX0NPRiA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVI7XG52YXIgVFJJTSA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmICghJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpIHtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpIHtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cbiIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKSB9KTtcbiIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpIH0pO1xuIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciAkdG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xudmFyIEVSUk9SID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnO1xudmFyIFpFUk8gPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIGMgPSAwO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4LjAudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUik7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSBaRVJPO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgJHRvUHJlY2lzaW9uID0gMS4wLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pO1xuICB9XG59KTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24gKCRmcmVlemUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCkge1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24gKCRpc0V4dGVuc2libGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24gKCRpc0Zyb3plbikge1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uICgkcHJldmVudEV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZVxuICAgICAgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgICAvLyB3ZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICAgICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDBcbiAgICAgICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciByQXBwbHkgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHk7XG52YXIgZkFwcGx5ID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByQXBwbHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KSB7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KTtcbiAgICB2YXIgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcbnZhciByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0KCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHsgdmFsdWU6IDEgfSksIDEsIHsgdmFsdWU6IDIgfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdOyAgICAgIC8vIGtleXNcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gaXRlcmF0ZWQpIGtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlzID0gdGhhdC5faztcbiAgdmFyIGtleTtcbiAgZG8ge1xuICAgIGlmICh0aGF0Ll9pID49IGtleXMubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH0gd2hpbGUgKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4geyB2YWx1ZToga2V5LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBnZXQ6IGdldCB9KTtcbiIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG4iLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuICB2YXIgb3duRGVzYyA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIHZhciBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZiAoIW93bkRlc2MpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYgKGhhcyhvd25EZXNjLCAndmFsdWUnKSkge1xuICAgIGlmIChvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yLmdldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iuc2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2UgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGNyZWF0ZURlc2MoMCwgVikpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IHNldDogc2V0IH0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcbi8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gICAgZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc2VhcmNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkc2VhcmNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIHByZXZpb3VzTGFzdEluZGV4ID0gcngubGFzdEluZGV4O1xuICAgICAgaWYgKCFzYW1lVmFsdWUocHJldmlvdXNMYXN0SW5kZXgsIDApKSByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgaWYgKCFzYW1lVmFsdWUocngubGFzdEluZGV4LCBwcmV2aW91c0xhc3RJbmRleCkpIHJ4Lmxhc3RJbmRleCA9IHByZXZpb3VzTGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkbWluID0gTWF0aC5taW47XG52YXIgJHB1c2ggPSBbXS5wdXNoO1xudmFyICRTUExJVCA9ICdzcGxpdCc7XG52YXIgTEVOR1RIID0gJ2xlbmd0aCc7XG52YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xudmFyIE1BWF9VSU5UMzIgPSAweGZmZmZmZmZmO1xuXG4vLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJ3gnLCAneScpIC0+IC94L3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyIFNVUFBPUlRTX1kgPSAhZmFpbHMoZnVuY3Rpb24gKCkgeyBSZWdFeHAoTUFYX1VJTlQzMiwgJ3knKTsgfSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBpbnRlcm5hbFNwbGl0O1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkgcmV0dXJuICRzcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF07XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6ICRzcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9ICRzcGxpdDtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICAgIHJldHVybiBzcGxpdHRlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gc3BsaXR0ZXIuY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KVxuICAgICAgICA6IGludGVybmFsU3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICBmdW5jdGlvbiAocmVnZXhwLCBsaW1pdCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCByZWdleHAsIHRoaXMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSAkc3BsaXQpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcblxuICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTtcblxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFNVUFBPUlRTX1kgPyByeCA6ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciBxID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFNVUFBPUlRTX1kgPyBxIDogMDtcbiAgICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgU1VQUE9SVFNfWSA/IFMgOiBTLnNsaWNlKHEpKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSAkbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChTVVBQT1JUU19ZID8gMCA6IHEpKSwgUy5sZW5ndGgpKSA9PT0gcFxuICAgICAgICApIHtcbiAgICAgICAgICBxID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHEsIHVuaWNvZGVNYXRjaGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxID0gcCA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEEucHVzaChTLnNsaWNlKHApKTtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZiAocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSkpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmICgkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBFTkRTX1dJVEggPSAnZW5kc1dpdGgnO1xudmFyICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSCk7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKTtcbiAgICB2YXIgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfTtcbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG4gICAgd2hpbGUgKGFMZW4gPiBpKSB7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH07XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSkge1xuICAgIHZhciB0cGwgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aCk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYgKGkgPCBhTGVuKSByZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX1NFVCA9ICdXZWFrU2V0JztcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX1NFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19TRVQpLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuL19vd24ta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG52YXIgV0VCS0lUX0JVRyA9IC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIFdFQktJVF9CVUcsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbnZhciBXRUJLSVRfQlVHID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogV0VCS0lUX0JVRywgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBNU0lFID0gL01TSUUgLlxcLi8udGVzdCh1c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdGltZSAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgYm91bmRBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBmYWxzZTtcbiAgICByZXR1cm4gc2V0KGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBmbiwgdGltZSk7XG4gIH07XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMTEnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2csXG4gICAgICByZVRyaW1TdGFydCA9IC9eXFxzKy8sXG4gICAgICByZVRyaW1FbmQgPSAvXFxzKyQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gICAgICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG90aGVyICE9ICdmdW5jdGlvbicgfHwgIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gICAgICogZXhlY3V0ZWQgaW1wb3J0YW50LCBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICAgICAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLCBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIHVwZGF0ZVdyYXBEZXRhaWxzKGdldFdyYXBEZXRhaWxzKHNvdXJjZSksIGJpdG1hc2spKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAgICogbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoJ3NvdXJjZVVSTCcgaW4gb3B0aW9uc1xuICAgICAgICAgID8gb3B0aW9ucy5zb3VyY2VVUkxcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gKGxvZGFzaEZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICAgIG5hbWVzID0gcmVhbE5hbWVzW2tleV0gfHwgKHJlYWxOYW1lc1trZXldID0gW10pO1xuXG4gICAgICAgIG5hbWVzLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIHNlbGYpO1xuICB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbiIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQgcHJpbnRNZSBmcm9tIFwiLi9wcmludFwiO1xyXG5pbXBvcnQgXCIuL3N0eWxlLnNjc3NcIjtcclxuaW1wb3J0IFwiLi9zdHlsZS5jc3NcIjtcclxuXHJcbmZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcclxuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGxldCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG5cclxuXHJcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBfLmpvaW4oWydIZWxsbycsICd3ZWJwYWNrJ10sICcgJyk7XHJcblxyXG4gIGJ0bi5pbm5lckhUTUwgPSBcIkNsaWNrIG1lIGFuZCBjaGVjayB0aGUgY29uc29sZSFcIjtcclxuICBidG4ub25jbGljayA9IHByaW50TWU7XHJcblxyXG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnRuKTtcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29tcG9uZW50KCkpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByaW50TWUoKSB7XHJcbiAgY29uc29sZS5sb2coJ0kgZ2V0IGNhbGxlZCBmcm9tIHByaW50LmpzIScpO1xyXG59IiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=